<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake (Tilt Control: iOS + Android)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --text:#e5e7eb; --accent:#22c55e; --danger:#ef4444; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at top, #1e293b, var(--bg));
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap {
      width: min(94vw, 560px);
      background: color-mix(in srgb, var(--panel) 85%, black 15%);
      border: 1px solid #334155;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 16px 40px rgba(0,0,0,.35);
    }
    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .pill { background: #0b1220; border: 1px solid #334155; border-radius: 999px; padding: 6px 10px; }
    canvas {
      width: 100%;
      aspect-ratio: 1/1;
      display: block;
      background: #020617;
      border: 1px solid #334155;
      border-radius: 10px;
      image-rendering: pixelated;
      touch-action: none;
    }
    .controls { margin-top: 10px; display:flex; justify-content:space-between; gap:8px; flex-wrap: wrap; font-size: 12px; color:#cbd5e1; }
    button { background:#0b1220; color:var(--text); border:1px solid #334155; border-radius:8px; padding:8px 10px; cursor:pointer; }
    button:hover { border-color:#64748b; }
    .gameover { color: var(--danger); font-weight: 700; margin-left: 8px; display: none; }
    .status { font-size: 12px; color:#cbd5e1; margin-top:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="pill">Score: <strong id="score">0</strong></div>
      <div class="pill">High Score: <strong id="high">0</strong></div>
      <div class="pill">Speed: <strong id="speed">8</strong> fps</div>
      <span class="gameover" id="gameover">Game Over — tap Restart</span>
    </div>
    <canvas id="game" width="420" height="420" aria-label="Snake tilt game"></canvas>
    <div class="controls">
      <div>
        <button id="enableTilt">Enable Tilt (iOS/Android)</button>
        <button id="calibrate">Calibrate Neutral</button>
        <button id="restart">Restart</button>
        <button id="pause">Pause</button>
      </div>
      <div>Fallback: Arrow keys / WASD</div>
    </div>
    <div class="status" id="tiltStatus">Tilt: not enabled</div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const highEl = document.getElementById('high');
      const speedEl = document.getElementById('speed');
      const gameOverEl = document.getElementById('gameover');
      const restartBtn = document.getElementById('restart');
      const pauseBtn = document.getElementById('pause');
      const enableTiltBtn = document.getElementById('enableTilt');
      const calibrateBtn = document.getElementById('calibrate');
      const tiltStatus = document.getElementById('tiltStatus');

      const size = 21;
      const cell = canvas.width / size;
      const baseFps = 8;
      const maxFps = 18;
      let fps = baseFps;
      let acc = 0;
      let last = 0;
      let running = true;
      let dead = false;

      const highKey = 'snake_tilt_high_score';
      let high = Number(localStorage.getItem(highKey) || 0);
      highEl.textContent = high;

      let snake, dir, nextDir, food, score;

      // Tilt state
      let tiltEnabled = false;
      let usingMotionFallback = false;
      let lastTiltTurn = 0;
      const tiltCooldownMs = 170;
      const tiltThreshold = 10;
      let neutralBeta = 0;
      let neutralGamma = 0;
      let lastBeta = 0;
      let lastGamma = 0;

      function reset() {
        snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
        dir = {x: 1, y: 0};
        nextDir = {x: 1, y: 0};
        score = 0;
        fps = baseFps;
        dead = false;
        running = true;
        gameOverEl.style.display = 'none';
        pauseBtn.textContent = 'Pause';
        placeFood();
        updateHud();
      }

      function updateHud() {
        scoreEl.textContent = score;
        highEl.textContent = high;
        speedEl.textContent = fps;
      }

      function placeFood() {
        while (true) {
          const x = Math.floor(Math.random() * size);
          const y = Math.floor(Math.random() * size);
          if (!snake.some(s => s.x === x && s.y === y)) {
            food = {x, y};
            return;
          }
        }
      }

      function turn(x, y) {
        if (x === -dir.x && y === -dir.y) return;
        nextDir = {x, y};
      }

      function normalizeByScreen(beta, gamma) {
        const o = (screen.orientation && typeof screen.orientation.angle === 'number')
          ? screen.orientation.angle
          : (typeof window.orientation === 'number' ? window.orientation : 0);
        const angle = ((o % 360) + 360) % 360;

        // Normalize controls across portrait/landscape on iOS/Android
        if (angle === 90) return { beta: -gamma, gamma: beta };
        if (angle === 270) return { beta: gamma, gamma: -beta };
        if (angle === 180) return { beta: -beta, gamma: -gamma };
        return { beta, gamma };
      }

      function handleTilt(rawBeta, rawGamma) {
        const now = Date.now();
        if (now - lastTiltTurn < tiltCooldownMs) return;

        const { beta, gamma } = normalizeByScreen(rawBeta, rawGamma);
        const b = beta - neutralBeta;
        const g = gamma - neutralGamma;

        if (Math.abs(g) > Math.abs(b)) {
          if (g > tiltThreshold) { turn(1, 0); lastTiltTurn = now; }
          else if (g < -tiltThreshold) { turn(-1, 0); lastTiltTurn = now; }
        } else {
          if (b > tiltThreshold) { turn(0, 1); lastTiltTurn = now; }
          else if (b < -tiltThreshold) { turn(0, -1); lastTiltTurn = now; }
        }
      }

      function onOrientation(e) {
        if (!tiltEnabled) return;
        if (typeof e.beta !== 'number' || typeof e.gamma !== 'number') return;
        lastBeta = e.beta;
        lastGamma = e.gamma;
        handleTilt(e.beta, e.gamma);
      }

      function onMotion(e) {
        if (!tiltEnabled || !usingMotionFallback) return;
        const acc = e.accelerationIncludingGravity;
        if (!acc) return;

        // Fallback estimate for browsers/devices where orientation is unreliable
        // Map gravity vector approx to beta/gamma-like axes
        const beta = (-acc.y || 0) * 6;
        const gamma = (acc.x || 0) * 6;
        lastBeta = beta;
        lastGamma = gamma;
        handleTilt(beta, gamma);
      }

      function calibrate() {
        neutralBeta = lastBeta || 0;
        neutralGamma = lastGamma || 0;
        tiltStatus.textContent = `Tilt: calibrated (β0=${neutralBeta.toFixed(1)}, γ0=${neutralGamma.toFixed(1)})`;
      }

      async function requestSensorPermissionIfNeeded() {
        // iOS 13+ requires explicit permission in a user gesture
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res !== 'granted') throw new Error('Orientation permission denied');
        }
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          const res2 = await DeviceMotionEvent.requestPermission();
          if (res2 !== 'granted') {
            // motion may fail while orientation still works; do not hard-fail
          }
        }
      }

      async function enableTilt() {
        try {
          await requestSensorPermissionIfNeeded();

          window.addEventListener('deviceorientation', onOrientation, true);
          window.addEventListener('devicemotion', onMotion, true);

          tiltEnabled = true;
          usingMotionFallback = true; // keep both listeners, orientation usually wins
          tiltStatus.textContent = 'Tilt: enabled (supports iOS + Android). Hold phone neutral and tap Calibrate.';
          enableTiltBtn.disabled = true;
          enableTiltBtn.textContent = 'Tilt Enabled';
        } catch (err) {
          tiltStatus.textContent = 'Tilt: unavailable or permission denied on this device/browser';
        }
      }

      function step() {
        if (!running || dead) return;
        dir = nextDir;
        const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

        if (head.x < 0 || head.y < 0 || head.x >= size || head.y >= size) return die();
        if (snake.some(seg => seg.x === head.x && seg.y === head.y)) return die();

        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
          score++;
          if (score > high) { high = score; localStorage.setItem(highKey, String(high)); }
          fps = Math.min(maxFps, baseFps + Math.floor(score / 2));
          placeFood();
        } else {
          snake.pop();
        }
        updateHud();
      }

      function die() { dead = true; running = false; gameOverEl.style.display = 'inline'; }

      function drawGrid() {
        ctx.fillStyle = '#020617';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(148,163,184,0.12)';
        ctx.lineWidth = 1;
        for (let i = 1; i < size; i++) {
          const p = i * cell;
          ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, canvas.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(canvas.width, p); ctx.stroke();
        }
      }

      function roundRect(x, y, w, h, r, fill) {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        if (fill) ctx.fill();
      }

      function drawFood() { ctx.fillStyle = '#ef4444'; roundRect(food.x * cell + 2, food.y * cell + 2, cell - 4, cell - 4, 6, true); }
      function drawSnake() {
        snake.forEach((s, i) => {
          ctx.fillStyle = i === 0 ? '#22c55e' : '#16a34a';
          roundRect(s.x * cell + 1.5, s.y * cell + 1.5, cell - 3, cell - 3, 5, true);
        });
      }

      function frame(ts) {
        const dt = (ts - last) / 1000 || 0;
        last = ts;
        acc += dt;
        const stepTime = 1 / fps;
        while (acc >= stepTime) { step(); acc -= stepTime; }
        drawGrid(); drawFood(); drawSnake();
        requestAnimationFrame(frame);
      }

      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();
        if (k === 'arrowup' || k === 'w') turn(0, -1);
        else if (k === 'arrowdown' || k === 's') turn(0, 1);
        else if (k === 'arrowleft' || k === 'a') turn(-1, 0);
        else if (k === 'arrowright' || k === 'd') turn(1, 0);
        else if (k === ' ') {
          if (dead) reset();
          else { running = !running; pauseBtn.textContent = running ? 'Pause' : 'Resume'; }
        }
      });

      enableTiltBtn.addEventListener('click', enableTilt);
      calibrateBtn.addEventListener('click', calibrate);
      restartBtn.addEventListener('click', reset);
      pauseBtn.addEventListener('click', () => {
        if (dead) return;
        running = !running;
        pauseBtn.textContent = running ? 'Pause' : 'Resume';
      });

      reset();
      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
